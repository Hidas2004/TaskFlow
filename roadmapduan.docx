üéØ D·ª∞ √ÅN: TASKFLOW - H·ªÜ TH·ªêNG QU·∫¢N L√ù C√îNG VI·ªÜC
M·ª•c ti√™u: X√¢y d·ª±ng h·ªá th·ªëng qu·∫£n l√Ω c√¥ng vi·ªác (Task Management) ho√†n ch·ªânh v·ªõi Golang, RESTful API, PostgreSQL ƒë·ªÉ ƒë∆∞a v√†o CV xin vi·ªác.
________________________________________
üìã T·ªîNG QUAN D·ª∞ √ÅN
T·∫°i sao ch·ªçn d·ª± √°n n√†y?
‚Ä¢	‚úÖ ƒê·ªß ph·ª©c t·∫°p ƒë·ªÉ th·ªÉ hi·ªán k·ªπ nƒÉng backend
‚Ä¢	‚úÖ Bao ph·ªß h·∫ßu h·∫øt k·ªπ nƒÉng: Auth, CRUD, Ph√¢n quy·ªÅn, Upload file
‚Ä¢	‚úÖ D·ªÖ m·ªü r·ªông v√† d·ªÖ demo khi ph·ªèng v·∫•n
‚Ä¢	‚úÖ L√† b√†i to√°n th·ª±c t·∫ø trong doanh nghi·ªáp
Tech Stack
‚Ä¢	Backend: Golang 1.21+
‚Ä¢	Framework: Gin
‚Ä¢	Database: PostgreSQL 15+
‚Ä¢	ORM: GORM
‚Ä¢	Authentication: JWT
‚Ä¢	Documentation: Swagger
‚Ä¢	Deployment: Docker, Railway/Render
T√≠nh nƒÉng ch√≠nh
1.	Authentication & Authorization (JWT)
2.	Qu·∫£n l√Ω User & Team
3.	Qu·∫£n l√Ω Tasks (CRUD, Filter, Search, Pagination)
4.	Comments & Attachments
5.	Dashboard & Statistics
________________________________________
üóÇÔ∏è C·∫§U TR√öC D·ª∞ √ÅN
taskflow/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ main.go                 # Entry point c·ªßa ·ª©ng d·ª•ng
‚îÇ
‚îú‚îÄ‚îÄ internal/                       # Code n·ªôi b·ªô (kh√¥ng export)
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.go              # ƒê·ªçc ENV variables
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ database.go            # K·∫øt n·ªëi database
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ models/                    # Database models
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ team.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ comment.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ attachment.go
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ repositories/              # Data access layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_repository.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ team_repository.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_repository.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ comment_repository.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ attachment_repository.go
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/                  # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_service.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_service.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ team_service.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_service.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ comment_service.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ attachment_service.go
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ handlers/                  # HTTP handlers (controllers)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_handler.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_handler.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ team_handler.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task_handler.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ comment_handler.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ attachment_handler.go
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_middleware.go     # Verify JWT token
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cors_middleware.go     # CORS handling
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logger_middleware.go   # Log requests
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ dto/                       # Data Transfer Objects
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth_dto.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_dto.go
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ team_dto.go
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task_dto.go
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt.go                # JWT generate/validate
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password.go           # Hash/compare password
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ response.go           # Standard API response
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.go          # Input validation
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ routes/
‚îÇ       ‚îî‚îÄ‚îÄ routes.go             # ƒê·ªãnh nghƒ©a t·∫•t c·∫£ routes
‚îÇ
‚îú‚îÄ‚îÄ migrations/                   # SQL migration files
‚îÇ   ‚îú‚îÄ‚îÄ 000001_create_users_table.up.sql
‚îÇ   ‚îú‚îÄ‚îÄ 000001_create_users_table.down.sql
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îú‚îÄ‚îÄ .env                         # Environment variables
‚îú‚îÄ‚îÄ .env.example                 # Template cho .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ go.mod
‚îú‚îÄ‚îÄ go.sum
‚îú‚îÄ‚îÄ Makefile                     # Command shortcuts
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ docker-compose.yml
________________________________________
üóÑÔ∏è THI·∫æT K·∫æ DATABASE
1. B·∫£ng users
sql
- id (UUID, primary key)
- email (unique, not null)
- password (hashed, not null)
- full_name (varchar)
- role (enum: 'admin', 'team_leader', 'member')
- avatar_url (varchar, nullable)
- created_at (timestamp)
- updated_at (timestamp)
- deleted_at (timestamp, nullable) -- soft delete
2. B·∫£ng teams
sql
- id (UUID, primary key)
- name (varchar, not null)
- description (text, nullable)
- leader_id (foreign key ‚Üí users.id)
- created_at (timestamp)
- updated_at (timestamp)
- deleted_at (timestamp, nullable)
3. B·∫£ng team_members (Many-to-Many)
sql
- id (primary key)
- team_id (foreign key ‚Üí teams.id)
- user_id (foreign key ‚Üí users.id)
- joined_at (timestamp)
- UNIQUE(team_id, user_id)
4. B·∫£ng tasks
sql
- id (UUID, primary key)
- title (varchar, not null)
- description (text, nullable)
- status (enum: 'todo', 'in_progress', 'review', 'done')
- priority (enum: 'low', 'medium', 'high', 'urgent')
- team_id (foreign key ‚Üí teams.id)
- assigned_to (foreign key ‚Üí users.id, nullable)
- created_by (foreign key ‚Üí users.id)
- due_date (timestamp, nullable)
- created_at (timestamp)
- updated_at (timestamp)
- deleted_at (timestamp, nullable)
5. B·∫£ng comments
sql
- id (primary key)
- task_id (foreign key ‚Üí tasks.id)
- user_id (foreign key ‚Üí users.id)
- content (text, not null)
- created_at (timestamp)
- updated_at (timestamp)
6. B·∫£ng attachments
sql
- id (primary key)
- task_id (foreign key ‚Üí tasks.id)
- uploaded_by (foreign key ‚Üí users.id)
- file_name (varchar)
- file_url (varchar)
- file_size (bigint)
- file_type (varchar)
- created_at (timestamp)
Quan h·ªá:
‚Ä¢	User 1-N Teams (as leader)
‚Ä¢	User N-N Teams (as member)
‚Ä¢	Team 1-N Tasks
‚Ä¢	User 1-N Tasks (as creator)
‚Ä¢	User 1-N Tasks (as assignee)
‚Ä¢	Task 1-N Comments
‚Ä¢	Task 1-N Attachments
________________________________________
üìö ROADMAP CHI TI·∫æT (6-8 TU·∫¶N)
PHASE 1: CHU·∫®N B·ªä & THI·∫æT K·∫æ (3-5 ng√†y)
B∆∞·ªõc 1.1: Thi·∫øt k·∫ø Database Schema
L√†m g√¨:
‚Ä¢	V·∫Ω s∆° ƒë·ªì ERD (Entity Relationship Diagram)
‚Ä¢	X√°c ƒë·ªãnh r√µ primary key, foreign key, indexes
‚Ä¢	X√°c ƒë·ªãnh quan h·ªá gi·ªØa c√°c b·∫£ng
D√πng g√¨:
‚Ä¢	Tool: dbdiagram.io ho·∫∑c draw.io (online, mi·ªÖn ph√≠)
Nhi·ªám v·ª•:
‚Ä¢	 V·∫Ω ERD ƒë·∫ßy ƒë·ªß 6 b·∫£ng
‚Ä¢	 X√°c ƒë·ªãnh r√µ primary key, foreign key
‚Ä¢	 X√°c ƒë·ªãnh quan h·ªá: 1-1, 1-N, N-N
________________________________________
B∆∞·ªõc 1.2: Setup M√¥i Tr∆∞·ªùng Ph√°t Tri·ªÉn
C√†i ƒë·∫∑t c·∫ßn thi·∫øt:
1.	Go (ƒë√£ c√≥)
bash
go version  # Ki·ªÉm tra version >= 1.21
2.	PostgreSQL
bash
# T·∫°o database
CREATE DATABASE taskflow_db;
3.	Tool qu·∫£n l√Ω DB (ch·ªçn 1)
‚Ä¢	DBeaver (mi·ªÖn ph√≠, ƒëa n·ªÅn t·∫£ng)
‚Ä¢	pgAdmin (cho PostgreSQL)
‚Ä¢	TablePlus (giao di·ªán ƒë·∫πp)
4.	Postman ho·∫∑c Insomnia (ƒë·ªÉ test API)
5.	Git
bash
git init
Nhi·ªám v·ª•:
‚Ä¢	 C√†i PostgreSQL v√† t·∫°o database
‚Ä¢	 C√†i tool qu·∫£n l√Ω DB v√† connect th√†nh c√¥ng
‚Ä¢	 C√†i Postman
‚Ä¢	 Init Git repo
________________________________________
B∆∞·ªõc 1.3: Kh·ªüi t·∫°o Project Go
L·ªánh th·ª±c hi·ªán:
bash
mkdir taskflow
cd taskflow
go mod init github.com/yourname/taskflow
T·∫°o c·∫•u tr√∫c th∆∞ m·ª•c:
bash
# T·∫°o t·∫•t c·∫£ folders theo c·∫•u tr√∫c ·ªü tr√™n
mkdir -p cmd/api
mkdir -p internal/{config,models,repositories,services,handlers,middlewares,dto,utils,routes}
mkdir -p migrations
T·∫°o files c∆° b·∫£n:
bash
touch cmd/api/main.go
touch .env .env.example .gitignore README.md
File .gitignore:
.env
*.log
tmp/
vendor/
*.exe
*.test
uploads/
Nhi·ªám v·ª•:
‚Ä¢	 T·∫°o CH√çNH X√ÅC c·∫•u tr√∫c th∆∞ m·ª•c
‚Ä¢	 Init go module
‚Ä¢	 T·∫°o .gitignore
________________________________________
PHASE 2: C√ÄI ƒê·∫∂T DEPENDENCIES & CONFIG (1 ng√†y)
B∆∞·ªõc 2.1: C√†i ƒë·∫∑t Th∆∞ Vi·ªán
Ch·∫°y t·ª´ng l·ªánh sau:
bash
# Gin Framework
go get -u github.com/gin-gonic/gin

# GORM - ORM
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres

# JWT
go get -u github.com/golang-jwt/jwt/v5

# Bcrypt
go get -u golang.org/x/crypto/bcrypt

# Validator
go get -u github.com/go-playground/validator/v10

# Godotenv
go get -u github.com/joho/godotenv

# UUID
go get -u github.com/google/uuid

# CORS
go get -u github.com/gin-contrib/cors

# Migrate
go get -u github.com/golang-migrate/migrate/v4
go get -u github.com/golang-migrate/migrate/v4/database/postgres
go get -u github.com/golang-migrate/migrate/v4/source/file

# Air - Hot reload (optional)
go install github.com/air-verse/air@latest
Nhi·ªám v·ª•:
‚Ä¢	 Ch·∫°y T·∫§T C·∫¢ l·ªánh tr√™n
‚Ä¢	 Ki·ªÉm tra go.mod ƒë√£ c√≥ ƒë·∫ßy ƒë·ªß dependencies
‚Ä¢	 Ch·∫°y go mod tidy
________________________________________
B∆∞·ªõc 2.2: T·∫°o File .env
File .env:
env
# Server
PORT=8080
GIN_MODE=debug

# Database
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=yourpassword
DB_NAME=taskflow_db
DB_SSLMODE=disable

# JWT
JWT_SECRET=your-super-secret-key-change-this-in-production
JWT_EXPIRE_HOURS=72

# File Upload
UPLOAD_PATH=./uploads
MAX_UPLOAD_SIZE=10485760
File .env.example:
env
PORT=8080
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=
DB_NAME=taskflow_db
JWT_SECRET=change-me
JWT_EXPIRE_HOURS=72
Nhi·ªám v·ª•:
‚Ä¢	 T·∫°o file .env v·ªõi th√¥ng tin database c·ªßa b·∫°n
‚Ä¢	 T·∫°o file .env.example
‚Ä¢	 ƒê·∫£m b·∫£o .env ƒë√£ n·∫±m trong .gitignore
________________________________________
B∆∞·ªõc 2.3: Vi·∫øt Config Loader
File: internal/config/config.go
Nhi·ªám v·ª•: Vi·∫øt struct v√† function ƒë·ªÉ:
‚Ä¢	ƒê·ªçc t·∫•t c·∫£ bi·∫øn m√¥i tr∆∞·ªùng t·ª´ .env
‚Ä¢	Load v√†o struct Config
‚Ä¢	Export function LoadConfig()
G·ª£i √Ω struct:
go
package config

import (
    "os"
    "strconv"
    "github.com/joho/godotenv"
)

type Config struct {
    ServerPort      string
    GinMode         string
    
    DBHost          string
    DBPort          string
    DBUser          string
    DBPassword      string
    DBName          string
    DBSSLMode       string
    
    JWTSecret       string
    JWTExpireHours  int
    
    UploadPath      string
    MaxUploadSize   int64
}

func LoadConfig() *Config {
    // Load .env file
    godotenv.Load()
    
    // ƒê·ªçc t·ª´ng bi·∫øn m√¥i tr∆∞·ªùng
    // Return Config struct
}
________________________________________
B∆∞·ªõc 2.4: Vi·∫øt Database Connection
File: internal/config/database.go
Nhi·ªám v·ª•: Vi·∫øt function ƒë·ªÉ:
‚Ä¢	K·∫øt n·ªëi PostgreSQL b·∫±ng GORM
‚Ä¢	Nh·∫≠n Config t·ª´ b∆∞·ªõc 2.3
‚Ä¢	Return *gorm.DB
‚Ä¢	X·ª≠ l√Ω l·ªói n·∫øu connect fail
G·ª£i √Ω:
go
package config

import (
    "fmt"
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
)

func ConnectDatabase(cfg *Config) (*gorm.DB, error) {
    // DSN format
    dsn := fmt.Sprintf(
        "host=%s user=%s password=%s dbname=%s port=%s sslmode=%s",
        cfg.DBHost, cfg.DBUser, cfg.DBPassword, 
        cfg.DBName, cfg.DBPort, cfg.DBSSLMode,
    )
    
    // Connect
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
    // Handle error
    // Return db
}
Nhi·ªám v·ª•:
‚Ä¢	 Vi·∫øt ConnectDatabase()
‚Ä¢	 Test k·∫øt n·ªëi th√†nh c√¥ng
________________________________________
PHASE 3: X√ÇY D·ª∞NG AUTHENTICATION (3-4 ng√†y)
B∆∞·ªõc 3.1: T·∫°o Models
File: internal/models/user.go
Nhi·ªám v·ª•: T·∫°o struct User v·ªõi:
‚Ä¢	T·∫•t c·∫£ field gi·ªëng b·∫£ng users
‚Ä¢	GORM tags
‚Ä¢	JSON tags
‚Ä¢	Password field: json:"-" (kh√¥ng tr·∫£ v·ªÅ API)
G·ª£i √Ω:
go
package models

import (
    "github.com/google/uuid"
    "time"
)

type User struct {
    ID        uuid.UUID `gorm:"type:uuid;primary_key;default:gen_random_uuid()" json:"id"`
    Email     string    `gorm:"unique;not null" json:"email"`
    Password  string    `gorm:"not null" json:"-"`
    FullName  string    `gorm:"not null" json:"full_name"`
    Role      string    `gorm:"type:varchar(50);not null;default:'member'" json:"role"`
    AvatarURL *string   `gorm:"type:varchar(500)" json:"avatar_url"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
    DeletedAt *time.Time `gorm:"index" json:"deleted_at,omitempty"`
}
________________________________________
B∆∞·ªõc 3.2: T·∫°o DTOs
File: internal/dto/auth_dto.go
Nhi·ªám v·ª•: T·∫°o struct cho:
1. RegisterRequest
go
type RegisterRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=6"`
    FullName string `json:"full_name" binding:"required"`
    Role     string `json:"role"`
}
2. LoginRequest
go
type LoginRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required"`
}
3. AuthResponse
go
type AuthResponse struct {
    Token string      `json:"token"`
    User  interface{} `json:"user"`
}
________________________________________
B∆∞·ªõc 3.3: Vi·∫øt Utils
File: internal/utils/password.go
Nhi·ªám v·ª•: Vi·∫øt 2 functions:
1.	HashPassword(password string) (string, error)
‚Ä¢	D√πng bcrypt.GenerateFromPassword()
2.	ComparePassword(hashedPassword, password string) bool
‚Ä¢	D√πng bcrypt.CompareHashAndPassword()
________________________________________
File: internal/utils/jwt.go
Nhi·ªám v·ª•: Vi·∫øt 2 functions:
1.	GenerateToken(userID, email, role, secret string, expireHours int) (string, error)
‚Ä¢	T·∫°o JWT claims v·ªõi: userID, email, role, exp
‚Ä¢	Sign b·∫±ng jwt.NewWithClaims()
2.	ValidateToken(tokenString, secret string) (*Claims, error)
‚Ä¢	Parse token
‚Ä¢	Validate
‚Ä¢	Return claims
G·ª£i √Ω Claims struct:
go
type Claims struct {
    UserID string `json:"user_id"`
    Email  string `json:"email"`
    Role   string `json:"role"`
    jwt.RegisteredClaims
}
________________________________________
File: internal/utils/response.go
Nhi·ªám v·ª•: Chu·∫©n h√≥a response:
go
type Response struct {
    Success bool        `json:"success"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
    Error   string      `json:"error,omitempty"`
}

func SuccessResponse(c *gin.Context, code int, message string, data interface{}) {
    c.JSON(code, Response{
        Success: true,
        Message: message,
        Data:    data,
    })
}

func ErrorResponse(c *gin.Context, code int, message string, err string) {
    c.JSON(code, Response{
        Success: false,
        Message: message,
        Error:   err,
    })
}
________________________________________
B∆∞·ªõc 3.4: Vi·∫øt Repository Layer
File: internal/repositories/user_repository.go
Nhi·ªám v·ª•: T·∫°o interface v√† struct:
go
type UserRepository interface {
    Create(user *models.User) error
    FindByEmail(email string) (*models.User, error)
    FindByID(id uuid.UUID) (*models.User, error)
    Update(user *models.User) error
    Delete(id uuid.UUID) error
}

type userRepository struct {
    db *gorm.DB
}

func NewUserRepository(db *gorm.DB) UserRepository {
    return &userRepository{db: db}
}
Implement t·∫•t c·∫£ methods:
‚Ä¢	Create: d√πng db.Create()
‚Ä¢	FindByEmail: d√πng db.Where("email = ?").First()
‚Ä¢	FindByID: d√πng db.First()
‚Ä¢	Update: d√πng db.Save()
‚Ä¢	Delete: d√πng db.Delete() (soft delete)
________________________________________
B∆∞·ªõc 3.5: Vi·∫øt Service Layer
File: internal/services/auth_service.go
Nhi·ªám v·ª•: T·∫°o interface v√† struct:
go
type AuthService interface {
    Register(req *dto.RegisterRequest) (*dto.AuthResponse, error)
    Login(req *dto.LoginRequest) (*dto.AuthResponse, error)
}

type authService struct {
    userRepo repositories.UserRepository
    config   *config.Config
}
Implement Register:
1.	Check email ƒë√£ t·ªìn t·∫°i ch∆∞a
2.	Hash password
3.	T·∫°o User model
4.	Save v√†o DB
5.	Generate JWT token
6.	Return AuthResponse
Implement Login:
1.	T√¨m user by email
2.	So s√°nh password
3.	Generate JWT token
4.	Return AuthResponse
X·ª≠ l√Ω l·ªói:
‚Ä¢	Email ƒë√£ t·ªìn t·∫°i
‚Ä¢	Email/password sai
‚Ä¢	L·ªói database
________________________________________
B∆∞·ªõc 3.6: Vi·∫øt Handler Layer
File: internal/handlers/auth_handler.go
Nhi·ªám v·ª•: T·∫°o struct:
go
type AuthHandler struct {
    authService services.AuthService
}

func NewAuthHandler(service services.AuthService) *AuthHandler {
    return &AuthHandler{authService: service}
}
Implement Register handler:
1.	Bind JSON request v√†o RegisterRequest (c.ShouldBindJSON)
2.	Validate (Gin t·ª± ƒë·ªông validate)
3.	G·ªçi authService.Register()
4.	Return response
Implement Login handler:
‚Ä¢	T∆∞∆°ng t·ª± Register
HTTP Status codes:
‚Ä¢	Success: 200 ho·∫∑c 201
‚Ä¢	Bad request: 400
‚Ä¢	Unauthorized: 401
‚Ä¢	Internal error: 500
________________________________________
B∆∞·ªõc 3.7: Setup Routes
File: internal/routes/routes.go
go
package routes

import (
    "github.com/gin-gonic/gin"
    "taskflow/internal/handlers"
)

func SetupRoutes(router *gin.Engine, authHandler *handlers.AuthHandler) {
    // Public routes (kh√¥ng c·∫ßn JWT)
    auth := router.Group("/api/auth")
    {
        auth.POST("/register", authHandler.Register)
        auth.POST("/login", authHandler.Login)
    }
    
    // Protected routes (c·∫ßn JWT) - l√†m sau
}
________________________________________
B∆∞·ªõc 3.8: Vi·∫øt main.go
File: cmd/api/main.go
Nhi·ªám v·ª•: Vi·∫øt entry point:
go
package main

import (
    "log"
    "github.com/gin-gonic/gin"
    "taskflow/internal/config"
    "taskflow/internal/repositories"
    "taskflow/internal/services"
    "taskflow/internal/handlers"
    "taskflow/internal/routes"
)

func main() {
    // Load config
    cfg := config.LoadConfig()
    
    // Connect database
    db, err := config.ConnectDatabase(cfg)
    if err != nil {
        log.Fatal("Failed to connect database:", err)
    }
    
    // Init layers
    userRepo := repositories.NewUserRepository(db)
    authService := services.NewAuthService(userRepo, cfg)
    authHandler := handlers.NewAuthHandler(authService)
    
    // Setup router
    router := gin.Default()
    routes.SetupRoutes(router, authHandler)
    
    // Run server
    log.Printf("Server running on port %s", cfg.ServerPort)
    router.Run(":" + cfg.ServerPort)
}
________________________________________
B∆∞·ªõc 3.9: Test Authentication
Nhi·ªám v·ª•:
1.	Ch·∫°y server:
bash
go run cmd/api/main.go
2.	Test Register b·∫±ng Postman:
POST http://localhost:8080/api/auth/register
Content-Type: application/json

{
  "email": "test@example.com",
  "password": "123456",
  "full_name": "Test User",
  "role": "member"
}
3.	Test Login:
POST http://localhost:8080/api/auth/login

{
  "email": "test@example.com",
  "password": "123456"
}
4.	Ki·ªÉm tra:
‚Ä¢	 Register th√†nh c√¥ng, tr·∫£ v·ªÅ token
‚Ä¢	 Register email tr√πng b√°o l·ªói
‚Ä¢	 Login th√†nh c√¥ng v·ªõi email/pass ƒë√∫ng
‚Ä¢	 Login sai pass b√°o l·ªói
‚Ä¢	 Token c√≥ decode ƒë∆∞·ª£c kh√¥ng (jwt.io)
________________________________________
PHASE 4: AUTHORIZATION MIDDLEWARE (1 ng√†y)
B∆∞·ªõc 4.1: Vi·∫øt Auth Middleware
File: internal/middlewares/auth_middleware.go
Nhi·ªám v·ª•: Vi·∫øt middleware AuthMiddleware() ƒë·ªÉ:
1.	L·∫•y token t·ª´ header Authorization: Bearer <token>
2.	Validate token
3.	L∆∞u user info v√†o context
4.	Next() n·∫øu valid, ng∆∞·ª£c l·∫°i return 401
G·ª£i √Ω:
go
func AuthMiddleware(secret string) gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        
        // Check format "Bearer token"
        if authHeader == "" {
            c.JSON(401, gin.H{"error": "Authorization header required"})
            c.Abort()
            return
        }
        
        // Extract token
        // Validate token
        // Set context: c.Set("userID", claims.UserID)
        // c.Next()
    }
}
________________________________________
B∆∞·ªõc 4.2: Vi·∫øt Role Middleware
File: internal/middlewares/auth_middleware.go
Nhi·ªám v·ª•: Vi·∫øt middleware RoleMiddleware():
go
func RoleMiddleware(allowedRoles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        role, exists := c.Get("role")
        if !exists {
            c.JSON(403, gin.H{"error": "Forbidden"})
            c.Abort()
            return
        }
        
        // Check role c√≥ trong allowedRoles kh√¥ng
        // Next() n·∫øu c√≥ quy·ªÅn, ng∆∞·ª£c l·∫°i 403
    }
}
________________________________________
B∆∞·ªõc 4.3: Test Protected Route
T·∫°o test route:
go
protected := router.Group("/api/users")
protected.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    protected.GET("/me", userHandler.GetProfile)
}
Vi·∫øt handler GetProfile:
‚Ä¢	L·∫•y userID t·ª´ context
‚Ä¢	Query user t·ª´ DB
‚Ä¢	Return user info
Test:
‚Ä¢	GET /api/users/me kh√¥ng c√≥ token ‚Üí 401
‚Ä¢	GET /api/users/me v·ªõi token h·ª£p l·ªá ‚Üí tr·∫£ v·ªÅ user info
________________________________________
PHASE 5: CRUD USERS (2 ng√†y)
B∆∞·ªõc 5.1: Ho√†n thi·ªán User Repository
Th√™m methods:
go
FindAll(page, limit int) ([]*models.User, int64, error)
Search(keyword string) ([]*models.User, error)
G·ª£i √Ω:
‚Ä¢	FindAll: d√πng db.Limit().Offset().Find() v√† db.Model().Count()
‚Ä¢	Search: d√πng db.Where("full_name ILIKE ?", "%"+keyword+"%")
________________________________________
B∆∞·ªõc 5.2: Vi·∫øt User Service
File: internal/services/user_service.go
Implement:
‚Ä¢	GetAllUsers(page, limit int)
‚Ä¢	GetUserByID(id uuid.UUID)
‚Ä¢	UpdateUser(id uuid.UUID, req dto.UpdateUserRequest)
‚Ä¢	DeleteUser(id uuid.UUID)
‚Ä¢	SearchUsers(keyword string)
________________________________________
B∆∞·ªõc 5.3: Vi·∫øt User Handlers
File: internal/handlers/user_handler.go
Implement handlers:
‚Ä¢	GetAll - GET /api/users
‚Ä¢	GetByID - GET /api/users/:id
‚Ä¢	Update - PUT /api/users/:id
‚Ä¢	Delete - DELETE /api/users/:id
‚Ä¢	Search - GET /api/users/search?keyword=...
________________________________________
B∆∞·ªõc 5.4: Update Routes
go
users := router.Group("/api/users")
users.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    users.GET("", middlewares.RoleMiddleware("admin"), userHandler.GetAll)
    users.GET("/:id", userHandler.GetByID)
    users.PUT("/:id", userHandler.Update)
    users.DELETE("/:id", middlewares.RoleMiddleware("admin"), userHandler.Delete)
}
________________________________________
B∆∞·ªõc 5.5: Test CRUD Users
Test t·∫•t c·∫£ endpoints:
‚Ä¢	 Get all users (v·ªõi pagination)
‚Ä¢	 Get user by ID
‚Ä¢	 Update user
‚Ä¢	 Delete user
‚Ä¢	 Search users
‚Ä¢	 Test ph√¢n quy·ªÅn (admin vs member)
________________________________________
PHASE 6: TEAMS MANAGEMENT (3 ng√†y)
B∆∞·ªõc 6.1: T·∫°o Models
File: internal/models/team.go
Nhi·ªám v·ª•:
‚Ä¢	T·∫°o struct Team
‚Ä¢	T·∫°o struct TeamMember (b·∫£ng trung gian)
‚Ä¢	Define relationships
G·ª£i √Ω:
go
type Team struct {
    ID          uuid.UUID `gorm:"type:uuid;primary_key" json:"id"`
    Name        string    `gorm:"not null" json:"name"`
    Description *string   `json:"description"`
    LeaderID    uuid.UUID `gorm:"not null" json:"leader_id"`
    Leader      User      `gorm:"foreignKey:LeaderID" json:"leader"`
    Members     []TeamMember `gorm:"foreignKey:TeamID" json:"members"`
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
    DeletedAt   *time.Time `gorm:"index" json:"deleted_at,omitempty"`
}

type TeamMember struct {
    ID       uint      `gorm:"primaryKey" json:"id"`
    TeamID   uuid.UUID `gorm:"not null" json:"team_id"`
    UserID   uuid.UUID `gorm:"not null" json:"user_id"`
    User     User      `gorm:"foreignKey:UserID" json:"user"`
    JoinedAt time.Time `json:"joined_at"`
}
________________________________________
B∆∞·ªõc 6.2: Vi·∫øt Repository
File: internal/repositories/team_repository.go
Implement methods:
go
type TeamRepository interface {
    Create(team *models.Team) error
    FindAll() ([]*models.Team, error)
    FindByID(id uuid.UUID) (*models.Team, error)
    Update(team *models.Team) error
    Delete(id uuid.UUID) error
    AddMember(teamID, userID uuid.UUID) error
    RemoveMember(teamID, userID uuid.UUID) error
    GetTeamMembers(teamID uuid.UUID) ([]*models.User, error)
    GetUserTeams(userID uuid.UUID) ([]*models.Team, error)
}
G·ª£i √Ω:
‚Ä¢	D√πng db.Preload("Leader").Preload("Members") ƒë·ªÉ load relations
‚Ä¢	AddMember: db.Create(&TeamMember{TeamID: ..., UserID: ...})
________________________________________
B∆∞·ªõc 6.3: Vi·∫øt DTOs
File: internal/dto/team_dto.go
T·∫°o:
go
type CreateTeamRequest struct {
    Name        string   `json:"name" binding:"required"`
    Description string   `json:"description"`
    MemberIDs   []string `json:"member_ids"`
}

type UpdateTeamRequest struct {
    Name        string `json:"name"`
    Description string `json:"description"`
}

type TeamResponse struct {
    ID          string      `json:"id"`
    Name        string      `json:"name"`
    Description string      `json:"description"`
    Leader      interface{} `json:"leader"`
    Members     interface{} `json:"members"`
    CreatedAt   time.Time   `json:"created_at"`
}

type AddMemberRequest struct {
    UserID string `json:"user_id" binding:"required"`
}
________________________________________
B∆∞·ªõc 6.4: Vi·∫øt Service
File: internal/services/team_service.go
Implement business logic:
CreateTeam(req, createdBy uuid.UUID)
‚Ä¢	Set ng∆∞·ªùi t·∫°o l√†m leader
‚Ä¢	T·∫°o team
‚Ä¢	Add members n·∫øu c√≥
GetAllTeams()
‚Ä¢	L·∫•y t·∫•t c·∫£ teams
GetTeamByID(id)
‚Ä¢	L·∫•y team v·ªõi ƒë·∫ßy ƒë·ªß th√¥ng tin leader v√† members
UpdateTeam(id, req, userID)
‚Ä¢	Check quy·ªÅn: ch·ªâ leader ho·∫∑c admin
‚Ä¢	Update team info
DeleteTeam(id, userID)
‚Ä¢	Check quy·ªÅn
‚Ä¢	Soft delete
AddMember(teamID, userID, requestBy)
‚Ä¢	Check quy·ªÅn: leader ho·∫∑c admin
‚Ä¢	Check user c√≥ t·ªìn t·∫°i kh√¥ng
‚Ä¢	Check ƒë√£ l√† member ch∆∞a
‚Ä¢	Add member
RemoveMember(teamID, userID, requestBy)
‚Ä¢	Check quy·ªÅn
‚Ä¢	Kh√¥ng ƒë∆∞·ª£c remove leader
‚Ä¢	Remove member
GetMyTeams(userID)
‚Ä¢	L·∫•y t·∫•t c·∫£ teams c·ªßa user
________________________________________
B∆∞·ªõc 6.5: Vi·∫øt Handlers
File: internal/handlers/team_handler.go
Implement:
‚Ä¢	Create - POST /api/teams
‚Ä¢	GetAll - GET /api/teams
‚Ä¢	GetByID - GET /api/teams/:id
‚Ä¢	Update - PUT /api/teams/:id
‚Ä¢	Delete - DELETE /api/teams/:id
‚Ä¢	AddMember - POST /api/teams/:id/members
‚Ä¢	RemoveMember - DELETE /api/teams/:id/members/:userId
‚Ä¢	GetMembers - GET /api/teams/:id/members
‚Ä¢	GetMyTeams - GET /api/teams/my
________________________________________
B∆∞·ªõc 6.6: Setup Routes
go
teams := router.Group("/api/teams")
teams.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    teams.POST("", teamHandler.Create)
    teams.GET("", teamHandler.GetAll)
    teams.GET("/my", teamHandler.GetMyTeams)
    teams.GET("/:id", teamHandler.GetByID)
    teams.PUT("/:id", teamHandler.Update)
    teams.DELETE("/:id", teamHandler.Delete)
    teams.POST("/:id/members", teamHandler.AddMember)
    teams.DELETE("/:id/members/:userId", teamHandler.RemoveMember)
    teams.GET("/:id/members", teamHandler.GetMembers)
}
________________________________________
B∆∞·ªõc 6.7: Test Teams
Test scenarios:
‚Ä¢	 T·∫°o team m·ªõi
‚Ä¢	 Get all teams
‚Ä¢	 Get team by ID (v·ªõi members)
‚Ä¢	 Update team (leader c√≥ quy·ªÅn)
‚Ä¢	 Update team (member kh√¥ng c√≥ quy·ªÅn) ‚Üí 403
‚Ä¢	 Add member v√†o team
‚Ä¢	 Remove member
‚Ä¢	 Delete team
‚Ä¢	 Get my teams
________________________________________
PHASE 7: TASKS MANAGEMENT (4 ng√†y)
B∆∞·ªõc 7.1: T·∫°o Models
File: internal/models/task.go
Nhi·ªám v·ª•:
‚Ä¢	T·∫°o struct Task
‚Ä¢	Define relationships
G·ª£i √Ω:
go
type Task struct {
    ID          uuid.UUID  `gorm:"type:uuid;primary_key" json:"id"`
    Title       string     `gorm:"not null" json:"title"`
    Description *string    `json:"description"`
    Status      string     `gorm:"type:varchar(50);default:'todo'" json:"status"`
    Priority    string     `gorm:"type:varchar(50);default:'medium'" json:"priority"`
    TeamID      uuid.UUID  `gorm:"not null" json:"team_id"`
    Team        Team       `gorm:"foreignKey:TeamID" json:"team"`
    AssignedTo  *uuid.UUID `json:"assigned_to"`
    Assignee    *User      `gorm:"foreignKey:AssignedTo" json:"assignee"`
    CreatedBy   uuid.UUID  `gorm:"not null" json:"created_by"`
    Creator     User       `gorm:"foreignKey:CreatedBy" json:"creator"`
    DueDate     *time.Time `json:"due_date"`
    CreatedAt   time.Time  `json:"created_at"`
    UpdatedAt   time.Time  `json:"updated_at"`
    DeletedAt   *time.Time `gorm:"index" json:"deleted_at,omitempty"`
}
________________________________________
B∆∞·ªõc 7.2: Vi·∫øt Repository
File: internal/repositories/task_repository.go
Implement methods:
go
type TaskRepository interface {
    Create(task *models.Task) error
    FindAll(filters map[string]interface{}, page, limit int) ([]*models.Task, int64, error)
    FindByID(id uuid.UUID) (*models.Task, error)
    Update(task *models.Task) error
    Delete(id uuid.UUID) error
    FindByTeamID(teamID uuid.UUID) ([]*models.Task, error)
    FindByAssignee(userID uuid.UUID) ([]*models.Task, error)
    Search(keyword string) ([]*models.Task, error)
}
G·ª£i √Ω dynamic filters:
go
query := db.Model(&models.Task{})

if teamID, ok := filters["team_id"]; ok {
    query = query.Where("team_id = ?", teamID)
}
if status, ok := filters["status"]; ok {
    query = query.Where("status = ?", status)
}
if priority, ok := filters["priority"]; ok {
    query = query.Where("priority = ?", priority)
}

// Preload relations
query.Preload("Team").Preload("Assignee").Preload("Creator")
________________________________________
B∆∞·ªõc 7.3: Vi·∫øt DTOs
File: internal/dto/task_dto.go
T·∫°o:
go
type CreateTaskRequest struct {
    Title       string  `json:"title" binding:"required"`
    Description string  `json:"description"`
    Priority    string  `json:"priority"`
    TeamID      string  `json:"team_id" binding:"required"`
    AssignedTo  *string `json:"assigned_to"`
    DueDate     *string `json:"due_date"`
}

type UpdateTaskRequest struct {
    Title       string  `json:"title"`
    Description string  `json:"description"`
    Priority    string  `json:"priority"`
    AssignedTo  *string `json:"assigned_to"`
    DueDate     *string `json:"due_date"`
}

type UpdateTaskStatusRequest struct {
    Status string `json:"status" binding:"required"`
}

type TaskFilterRequest struct {
    TeamID     string `form:"team_id"`
    Status     string `form:"status"`
    Priority   string `form:"priority"`
    AssignedTo string `form:"assigned_to"`
    Page       int    `form:"page"`
    Limit      int    `form:"limit"`
}

type TaskResponse struct {
    ID          string      `json:"id"`
    Title       string      `json:"title"`
    Description string      `json:"description"`
    Status      string      `json:"status"`
    Priority    string      `json:"priority"`
    Team        interface{} `json:"team"`
    Assignee    interface{} `json:"assignee"`
    Creator     interface{} `json:"creator"`
    DueDate     *time.Time  `json:"due_date"`
    CreatedAt   time.Time   `json:"created_at"`
}
________________________________________
B∆∞·ªõc 7.4: Vi·∫øt Service
File: internal/services/task_service.go
Implement business logic:
CreateTask:
‚Ä¢	Check team c√≥ t·ªìn t·∫°i kh√¥ng
‚Ä¢	Check assignee (n·∫øu c√≥) c√≥ trong team kh√¥ng
‚Ä¢	Set created_by
‚Ä¢	Set default status = "todo"
‚Ä¢	Create task
GetTasks (v·ªõi filters):
‚Ä¢	Build filters t·ª´ request
‚Ä¢	√Åp d·ª•ng ph√¢n quy·ªÅn:
‚Ä¢	Admin: xem t·∫•t c·∫£
‚Ä¢	Team leader: xem tasks c·ªßa teams m√¨nh lead
‚Ä¢	Member: xem tasks c·ªßa teams m√¨nh thu·ªôc v·ªÅ
GetTaskByID:
‚Ä¢	Check quy·ªÅn xem task (ph·∫£i thu·ªôc team)
UpdateTask:
‚Ä¢	Check quy·ªÅn update:
‚Ä¢	Creator c√≥ th·ªÉ update
‚Ä¢	Leader c·ªßa team c√≥ th·ªÉ update
‚Ä¢	Admin c√≥ th·ªÉ update
UpdateTaskStatus:
‚Ä¢	Validate status transition:
‚Ä¢	todo ‚Üí in_progress
‚Ä¢	in_progress ‚Üí review
‚Ä¢	review ‚Üí done ho·∫∑c in_progress
‚Ä¢	Check quy·ªÅn: assignee, creator, leader, admin
AssignTask:
‚Ä¢	Check user c√≥ trong team kh√¥ng
‚Ä¢	Update assigned_to
DeleteTask:
‚Ä¢	Check quy·ªÅn: creator, leader, admin
‚Ä¢	Soft delete
GetMyTasks:
‚Ä¢	L·∫•y tasks ƒë∆∞·ª£c assign cho user
GetTeamTasks:
‚Ä¢	L·∫•y tasks c·ªßa m·ªôt team
‚Ä¢	Check user c√≥ trong team kh√¥ng
________________________________________
B∆∞·ªõc 7.5: Vi·∫øt Handlers
File: internal/handlers/task_handler.go
Implement:
‚Ä¢	Create - POST /api/tasks
‚Ä¢	GetAll - GET /api/tasks (v·ªõi query params filters)
‚Ä¢	GetByID - GET /api/tasks/:id
‚Ä¢	Update - PUT /api/tasks/:id
‚Ä¢	UpdateStatus - PATCH /api/tasks/:id/status
‚Ä¢	Assign - PATCH /api/tasks/:id/assign
‚Ä¢	Delete - DELETE /api/tasks/:id
‚Ä¢	GetMyTasks - GET /api/tasks/my
‚Ä¢	GetTeamTasks - GET /api/teams/:teamId/tasks
‚Ä¢	Search - GET /api/tasks/search?keyword=...
________________________________________
B∆∞·ªõc 7.6: Setup Routes
go
tasks := router.Group("/api/tasks")
tasks.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    tasks.POST("", taskHandler.Create)
    tasks.GET("", taskHandler.GetAll) // Support filters
    tasks.GET("/my", taskHandler.GetMyTasks)
    tasks.GET("/search", taskHandler.Search)
    tasks.GET("/:id", taskHandler.GetByID)
    tasks.PUT("/:id", taskHandler.Update)
    tasks.PATCH("/:id/status", taskHandler.UpdateStatus)
    tasks.PATCH("/:id/assign", taskHandler.Assign)
    tasks.DELETE("/:id", taskHandler.Delete)
}

// Team tasks
teams := router.Group("/api/teams")
teams.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    teams.GET("/:id/tasks", taskHandler.GetTeamTasks)
}
________________________________________
B∆∞·ªõc 7.7: Test Tasks
Test scenarios:
‚Ä¢	 Create task v·ªõi team h·ª£p l·ªá
‚Ä¢	 Create task v·ªõi team kh√¥ng t·ªìn t·∫°i ‚Üí 404
‚Ä¢	 Assign task cho user kh√¥ng trong team ‚Üí 400
‚Ä¢	 Get all tasks v·ªõi filters (status, priority, team_id)
‚Ä¢	 Get my tasks
‚Ä¢	 Get team tasks (member c√≥ quy·ªÅn)
‚Ä¢	 Get team tasks (user kh√¥ng trong team) ‚Üí 403
‚Ä¢	 Update task (creator c√≥ quy·ªÅn)
‚Ä¢	 Update task (kh√¥ng c√≥ quy·ªÅn) ‚Üí 403
‚Ä¢	 Update status theo flow h·ª£p l·ªá
‚Ä¢	 Update status kh√¥ng h·ª£p l·ªá (todo ‚Üí done) ‚Üí 400
‚Ä¢	 Delete task
‚Ä¢	 Search tasks
________________________________________
PHASE 8: COMMENTS SYSTEM (2 ng√†y)
B∆∞·ªõc 8.1: T·∫°o Models
File: internal/models/comment.go
go
type Comment struct {
    ID        uint       `gorm:"primaryKey" json:"id"`
    TaskID    uuid.UUID  `gorm:"not null" json:"task_id"`
    Task      Task       `gorm:"foreignKey:TaskID" json:"task"`
    UserID    uuid.UUID  `gorm:"not null" json:"user_id"`
    User      User       `gorm:"foreignKey:UserID" json:"user"`
    Content   string     `gorm:"type:text;not null" json:"content"`
    CreatedAt time.Time  `json:"created_at"`
    UpdatedAt time.Time  `json:"updated_at"`
}
________________________________________
B∆∞·ªõc 8.2: Vi·∫øt Repository
File: internal/repositories/comment_repository.go
Implement:
go
type CommentRepository interface {
    Create(comment *models.Comment) error
    FindByTaskID(taskID uuid.UUID) ([]*models.Comment, error)
    FindByID(id uint) (*models.Comment, error)
    Update(comment *models.Comment) error
    Delete(id uint) error
}
________________________________________
B∆∞·ªõc 8.3: Vi·∫øt DTOs, Service, Handlers
DTOs:
go
type CreateCommentRequest struct {
    TaskID  string `json:"task_id" binding:"required"`
    Content string `json:"content" binding:"required"`
}

type UpdateCommentRequest struct {
    Content string `json:"content" binding:"required"`
}

type CommentResponse struct {
    ID        uint        `json:"id"`
    TaskID    string      `json:"task_id"`
    User      interface{} `json:"user"`
    Content   string      `json:"content"`
    CreatedAt time.Time   `json:"created_at"`
}
Service business logic:
‚Ä¢	CreateComment: Check user c√≥ quy·ªÅn access task kh√¥ng
‚Ä¢	GetComments: Check quy·ªÅn xem task
‚Ä¢	UpdateComment: Ch·ªâ author c√≥ quy·ªÅn s·ª≠a
‚Ä¢	DeleteComment: Author ho·∫∑c admin c√≥ quy·ªÅn x√≥a
Handlers:
‚Ä¢	Create - POST /api/comments
‚Ä¢	GetByTask - GET /api/tasks/:taskId/comments
‚Ä¢	Update - PUT /api/comments/:id
‚Ä¢	Delete - DELETE /api/comments/:id
________________________________________
B∆∞·ªõc 8.4: Setup Routes
go
comments := router.Group("/api/comments")
comments.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    comments.POST("", commentHandler.Create)
    comments.PUT("/:id", commentHandler.Update)
    comments.DELETE("/:id", commentHandler.Delete)
}

tasks.GET("/:id/comments", commentHandler.GetByTask)
________________________________________
B∆∞·ªõc 8.5: Test Comments
‚Ä¢	 Create comment
‚Ä¢	 Get comments c·ªßa task
‚Ä¢	 Update comment (author)
‚Ä¢	 Update comment (kh√¥ng ph·∫£i author) ‚Üí 403
‚Ä¢	 Delete comment
________________________________________
PHASE 9: FILE ATTACHMENTS (3 ng√†y)
B∆∞·ªõc 9.1: T·∫°o Models
File: internal/models/attachment.go
go
type Attachment struct {
    ID         uint      `gorm:"primaryKey" json:"id"`
    TaskID     uuid.UUID `gorm:"not null" json:"task_id"`
    Task       Task      `gorm:"foreignKey:TaskID" json:"task"`
    UploadedBy uuid.UUID `gorm:"not null" json:"uploaded_by"`
    Uploader   User      `gorm:"foreignKey:UploadedBy" json:"uploader"`
    FileName   string    `gorm:"not null" json:"file_name"`
    FileURL    string    `gorm:"not null" json:"file_url"`
    FileSize   int64     `json:"file_size"`
    FileType   string    `json:"file_type"`
    CreatedAt  time.Time `json:"created_at"`
}
________________________________________
B∆∞·ªõc 9.2: Setup File Upload
File: internal/utils/file_upload.go
Nhi·ªám v·ª•: Vi·∫øt functions:
*1. SaveFile(file multipart.FileHeader, uploadPath string) (string, error)
‚Ä¢	Generate unique filename (UUID + timestamp)
‚Ä¢	L∆∞u file v√†o uploadPath
‚Ä¢	Return ƒë∆∞·ªùng d·∫´n file
go
func SaveFile(file *multipart.FileHeader, uploadPath string) (string, error) {
    // Generate unique filename
    ext := filepath.Ext(file.Filename)
    filename := fmt.Sprintf("%s_%d%s", uuid.New().String(), time.Now().Unix(), ext)
    
    // Create full path
    fullPath := filepath.Join(uploadPath, filename)
    
    // Save file
    // Return filename or URL
}
*2. ValidateFile(file multipart.FileHeader, maxSize int64, allowedTypes []string) error
‚Ä¢	Check file size
‚Ä¢	Check file type (extension ho·∫∑c MIME type)
3. DeleteFile(filePath string) error
‚Ä¢	X√≥a file kh·ªèi disk
________________________________________
B∆∞·ªõc 9.3: T·∫°o uploads folder
bash
mkdir -p uploads/attachments/tasks
mkdir -p uploads/avatars
Serve static files trong main.go:
go
router.Static("/uploads", "./uploads")
________________________________________
B∆∞·ªõc 9.4: Vi·∫øt Repository, Service, Handler
Repository:
‚Ä¢	CRUD cho Attachment
‚Ä¢	FindByTaskID
Service:
‚Ä¢	UploadAttachment: Validate, save file, create DB record
‚Ä¢	GetAttachments: Check quy·ªÅn xem task
‚Ä¢	DeleteAttachment: Delete file + DB record, check quy·ªÅn
Handler:
‚Ä¢	Upload - POST /api/tasks/:taskId/attachments (multipart/form-data)
‚Ä¢	GetByTask - GET /api/tasks/:taskId/attachments
‚Ä¢	Delete - DELETE /api/attachments/:id
‚Ä¢	Download - GET /api/attachments/:id/download
G·ª£i √Ω Upload handler:
go
func (h *AttachmentHandler) Upload(c *gin.Context) {
    file, err := c.FormFile("file")
    if err != nil {
        // Handle error
        return
    }
    
    // Validate file
    // Save file
    // Create attachment record
    // Return URL
}
________________________________________
B∆∞·ªõc 9.5: Setup Routes
go
tasks.POST("/:id/attachments", attachmentHandler.Upload)
tasks.GET("/:id/attachments", attachmentHandler.GetByTask)

attachments := router.Group("/api/attachments")
attachments.Use(middlewares.AuthMiddleware(cfg.JWTSecret))
{
    attachments.DELETE("/:id", attachmentHandler.Delete)
    attachments.GET("/:id/download", attachmentHandler.Download)
}
________________________________________
B∆∞·ªõc 9.6: Test File Upload
Test v·ªõi Postman:
‚Ä¢	 Upload file (ch·ªçn form-data, key="file", type=File)
‚Ä¢	 File l∆∞u v√†o uploads/attachments/tasks/
‚Ä¢	 Response tr·∫£ v·ªÅ URL
‚Ä¢	 GET URL c√≥ download ƒë∆∞·ª£c file kh√¥ng
‚Ä¢	 Upload file qu√° size ‚Üí 400
‚Ä¢	 Upload file kh√¥ng ƒë√∫ng type ‚Üí 400
‚Ä¢	 Delete attachment
________________________________________
PHASE 10: ADVANCED FEATURES (3 ng√†y)
B∆∞·ªõc 10.1: Pagination Helper
File: internal/utils/pagination.go
go
type PaginationParams struct {
    Page  int `form:"page"`
    Limit int `form:"limit"`
}

type PaginationResponse struct {
    Data       interface{} `json:"data"`
    Page       int         `json:"page"`
    Limit      int         `json:"limit"`
    TotalPages int         `json:"total_pages"`
    TotalItems int64       `json:"total_items"`
}

func Paginate(page, limit int) (offset int, validLimit int) {
    if page < 1 {
        page = 1
    }
    if limit < 1 || limit > 100 {
        limit = 10
    }
    offset = (page - 1) * limit
    return offset, limit
}

func NewPaginationResponse(data interface{}, page, limit int, totalItems int64) *PaginationResponse {
    totalPages := int((totalItems + int64(limit) - 1) / int64(limit))
    return &PaginationResponse{
        Data:       data,
        Page:       page,
        Limit:      limit,
        TotalPages: totalPages,
        TotalItems: totalItems,
    }
}
√Åp d·ª•ng cho t·∫•t c·∫£ list endpoints
________________________________________
B∆∞·ªõc 10.2: Search & Filter Enhancement
Nhi·ªám v·ª•: N√¢ng c·∫•p search tasks:
‚Ä¢	Full-text search (ILIKE trong PostgreSQL)
‚Ä¢	Multiple filters (status, priority, assignee, date range)
‚Ä¢	Sort by (created_at, due_date, priority)
‚Ä¢	Combined search + filter + sort + pagination
V√≠ d·ª• API:
GET /api/tasks?
  keyword=bug&
  status=in_progress&
  priority=high&
  assigned_to=uuid&
  sort_by=due_date&
  order=asc&
  page=1&
  limit=20
________________________________________
B∆∞·ªõc 10.3: Dashboard Statistics API
File: internal/handlers/dashboard_handler.go
Implement endpoints:
1. GET /api/dashboard/stats
‚Ä¢	Total tasks
‚Ä¢	Tasks by status (breakdown)
‚Ä¢	Tasks by priority
‚Ä¢	My tasks count
‚Ä¢	Overdue tasks count
2. GET /api/dashboard/my-summary
‚Ä¢	My tasks by status
‚Ä¢	My tasks by priority
‚Ä¢	Tasks assigned to me
‚Ä¢	Tasks I created
3. GET /api/dashboard/team-summary/:teamId
‚Ä¢	Team tasks statistics
‚Ä¢	Member workload (tasks per member)
‚Ä¢	Completion rate
G·ª£i √Ω GORM:
go
type StatusCount struct {
    Status string
    Count  int64
}

var results []StatusCount
db.Model(&models.Task{}).
   Select("status, count(*) as count").
   Where("team_id = ?", teamID).
   Group("status").
   Scan(&results)
________________________________________
B∆∞·ªõc 10.4: Activity Log (Optional)
T·∫°o b·∫£ng activity_logs:
sql
- id
- user_id
- action (created, updated, deleted, assigned...)
- entity_type (task, comment, team...)
- entity_id
- description
- created_at
T√≠ch h·ª£p:
‚Ä¢	Log m·ªói khi create/update/delete task
‚Ä¢	GET /api/tasks/:id/activities - Xem l·ªãch s·ª≠ task
‚Ä¢	GET /api/activities - Xem to√†n b·ªô activities (admin)
________________________________________
PHASE 11: VALIDATION & ERROR HANDLING (2 ng√†y)
B∆∞·ªõc 11.1: Custom Validator
File: internal/utils/validator.go
T·∫°o custom validators:
go
import "github.com/go-playground/validator/v10"

var validate = validator.New()

// Register custom validators
func init() {
    validate.RegisterValidation("task_status", validateTaskStatus)
    validate.RegisterValidation("task_priority", validateTaskPriority)
}

func validateTaskStatus(fl validator.FieldLevel) bool {
    status := fl.Field().String()
    validStatuses := []string{"todo", "in_progress", "review", "done"}
    for _, v := range validStatuses {
        if status == v {
            return true
        }
    }
    return false
}

func validateTaskPriority(fl validator.FieldLevel) bool {
    priority := fl.Field().String()
    validPriorities := []string{"low", "medium", "high", "urgent"}
    for _, v := range validPriorities {
        if priority == v {
            return true
        }
    }
    return false
}
________________________________________
B∆∞·ªõc 11.2: Centralized Error Handling
File: internal/utils/errors.go
T·∫°o custom error types:
go
type AppError struct {
    Code    int
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

var (
    ErrNotFound      = &AppError{Code: 404, Message: "Resource not found"}
    ErrUnauthorized  = &AppError{Code: 401, Message: "Unauthorized"}
    ErrForbidden     = &AppError{Code: 403, Message: "Forbidden"}
    ErrBadRequest    = &AppError{Code: 400, Message: "Bad request"}
    ErrInternalError = &AppError{Code: 500, Message: "Internal server error"}
)
T·∫°o Error Middleware:
go
func ErrorHandler() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()
        
        if len(c.Errors) > 0 {
            err := c.Errors.Last()
            // Handle different error types
            // Return appropriate response
        }
    }
}
________________________________________
B∆∞·ªõc 11.3: Input Validation Middleware
go
func ValidateRequest(schema interface{}) gin.HandlerFunc {
    return func(c *gin.Context) {
        if err := c.ShouldBindJSON(schema); err != nil {
            utils.ErrorResponse(c, 400, "Validation failed", err.Error())
            c.Abort()
            return
        }
        c.Next()
    }
}
S·ª≠ d·ª•ng:
go
tasks.POST("",
    ValidateRequest(&dto.CreateTaskRequest{}),
    taskHandler.Create
)
________________________________________
PHASE 12: SECURITY ENHANCEMENTS (2 ng√†y)
B∆∞·ªõc 12.1: CORS Middleware
File: internal/middlewares/cors_middleware.go
go
import "github.com/gin-contrib/cors"

func SetupCORS(router *gin.Engine) {
    config := cors.DefaultConfig()
    config.AllowOrigins = []string{"http://localhost:3000"}
    config.AllowMethods = []string{"GET", "POST", "PUT", "PATCH", "DELETE"}
    config.AllowHeaders = []string{"Authorization", "Content-Type"}
    config.ExposeHeaders = []string{"Content-Length"}
    config.AllowCredentials = true
    
    router.Use(cors.New(config))
}
________________________________________
B∆∞·ªõc 12.2: Rate Limiting
C√†i ƒë·∫∑t:
bash
go get github.com/ulule/limiter/v3
go get github.com/ulule/limiter/v3/drivers/store/memory
T·∫°o middleware:
go
import (
    "github.com/ulule/limiter/v3"
    mgin "github.com/ulule/limiter/v3/drivers/middleware/gin"
    "github.com/ulule/limiter/v3/drivers/store/memory"
)

func RateLimitMiddleware() gin.HandlerFunc {
    rate := limiter.Rate{
        Period: 1 * time.Minute,
        Limit:  100,
    }
    
    store := memory.NewStore()
    middleware := mgin.NewMiddleware(limiter.New(store, rate))
    
    return middleware
}
________________________________________
B∆∞·ªõc 12.3: Request ID & Logging
File: internal/middlewares/logger_middleware.go
go
func RequestLogger() gin.HandlerFunc {
    return func(c *gin.Context) {
        // Generate request ID
        requestID := uuid.New().String()
        c.Set("request_id", requestID)
        c.Header("X-Request-ID", requestID)
        
        // Start timer
        start := time.Now()
        
        // Process request
        c.Next()
        
        // Log request
        duration := time.Since(start)
        log.Printf(
            "[%s] %s %s %d %v",
            requestID,
            c.Request.Method,
            c.Request.URL.Path,
            c.Writer.Status(),
            duration,
        )
    }
}
________________________________________
B∆∞·ªõc 12.4: Security Headers
go
func SecurityHeaders() gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Strict-Transport-Security", "max-age=31536000")
        c.Header("Content-Security-Policy", "default-src 'self'")
        c.Next()
    }
}
________________________________________
PHASE 13: TESTING (3 ng√†y)
B∆∞·ªõc 13.1: Setup Testing
C√†i ƒë·∫∑t:
bash
go get github.com/stretchr/testify
T·∫°o test database:
sql
CREATE DATABASE taskflow_test;
________________________________________
B∆∞·ªõc 13.2: Unit Tests
Test t·ª´ng layer:
1. Utils Tests
go
// internal/utils/password_test.go
func TestHashPassword(t *testing.T) {
    password := "test123"
    hashed, err := HashPassword(password)
    
    assert.NoError(t, err)

